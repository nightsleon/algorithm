# Binary Search 二分查找算法

## 难度级别
Intermediate

## 算法分类说明
本包专注于二分查找相关的算法，包括：
- **基础二分查找**：在有序数组中查找目标值
- **边界查找**：查找第一个/最后一个位置
- **二维矩阵查找**：在有序二维矩阵中查找
- **旋转数组查找**：在旋转排序数组中查找
- **峰值查找**：查找数组中的峰值元素

## 包含算法详解

### 🔍 基础二分查找算法

#### 1. SearchInsert (35. 搜索插入位置)
**题目**: 给定一个排序数组和目标值，找到目标值的索引，如果不存在则返回插入位置

**核心思想**: 标准二分查找 + 插入位置处理
- **步骤**: 二分查找目标值 → 找到返回索引 → 未找到返回插入位置
- **时间复杂度**: O(log n)
- **空间复杂度**: O(1)

**解题思路**:
1. 处理边界情况：空数组、目标值超出范围
2. 使用标准二分查找寻找目标值
3. 如果找到目标值，直接返回索引
4. 如果未找到，返回 `left` 指针位置（插入位置）

**关键技巧**:
- 边界优化：提前处理超出数组范围的情况
- 插入位置：未找到时 `left` 指针就是插入位置
- 循环终止：使用 `left <= right` 确保找到所有可能

**示例**:
```
输入: nums = [1,3,5,6], target = 5 → 输出: 2
输入: nums = [1,3,5,6], target = 2 → 输出: 1
```

### 📊 二维矩阵查找算法

#### 2. SearchMatrix (74. 搜索二维矩阵)
**题目**: 在满足特定条件的二维矩阵中查找目标值

**核心思想**: 先找行，再在行内二分查找
- **步骤**: 遍历找到目标行 → 在目标行内二分查找
- **时间复杂度**: O(m + log n)
- **空间复杂度**: O(1)

**解题思路**:
1. 处理空矩阵情况
2. 遍历所有行，找到目标值可能存在的行
3. 在找到的行内使用二分查找
4. 如果没找到合适的行，直接返回false

**关键技巧**:
- 行选择：`target <= matrix[i][cols-1]` 确定目标行
- 边界处理：`currRow == -1` 表示没找到合适行
- 二分查找：在确定行内进行标准二分查找

**示例**:
```
输入: matrix = [[1,4,7,11],[2,5,8,12],[3,6,9,16]], target = 5
输出: true
```

#### 3. SearchMatrixII (74. 搜索二维矩阵 - 优化版)
**题目**: 使用一维化方法在二维矩阵中查找目标值

**核心思想**: 将二维矩阵视为一维数组进行二分查找
- **步骤**: 坐标转换 → 一维二分查找 → 结果转换
- **时间复杂度**: O(log(m×n))
- **空间复杂度**: O(1)

**解题思路**:
1. 将二维矩阵视为一维数组
2. 使用坐标转换：`row = mid / cols`, `col = mid % cols`
3. 在一维数组上进行标准二分查找
4. 通过坐标转换获取实际值进行比较

**关键技巧**:
- 坐标转换：一维索引与二维坐标的相互转换
- 整体有序：利用矩阵的整体有序性质
- 效率优化：从O(m + log n)优化到O(log(m×n))

**示例**:
```
输入: matrix = [[1,4,7,11],[2,5,8,12],[3,6,9,16]], target = 5
输出: true
```

### 🏔️ 峰值查找算法

#### 4. FindPeakElement (162. 寻找峰值)
**题目**: 在数组中找到一个峰值元素（严格大于相邻元素）

**核心思想**: 利用数组性质，最大值就是峰值
- **步骤**: 遍历数组 → 找到最大值 → 返回索引
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

**解题思路**:
1. 利用前提条件：`nums[i] != nums[i+1]`
2. 遍历数组找到最大值
3. 最大值必然是峰值（严格大于相邻元素）

**关键技巧**:
- 性质利用：利用题目给出的特殊条件
- 简单直接：最大值就是峰值
- 边界安全：不需要考虑边界情况

**示例**:
```
输入: nums = [1,2,3,1] → 输出: 2 (索引2的值3是峰值)
输入: nums = [1,2,1,3,5,6,4] → 输出: 5 (索引5的值6是峰值)
```

#### 5. FindPeakElementBs (162. 寻找峰值 - 二分查找版)
**题目**: 使用二分查找在数组中找峰值

**核心思想**: 二分查找 + 趋势判断
- **步骤**: 比较相邻元素 → 判断趋势 → 选择搜索方向
- **时间复杂度**: O(log n)
- **空间复杂度**: O(1)

**解题思路**:
1. 比较 `nums[mid]` 和 `nums[mid+1]`
2. 如果 `nums[mid] < nums[mid+1]`，峰值在右侧
3. 否则，峰值在左侧或mid处
4. 使用 `left < right` 循环直到找到峰值

**关键技巧**:
- 趋势判断：通过比较相邻元素判断搜索方向
- 边界处理：使用 `left < right` 避免越界
- 效率优化：从O(n)优化到O(log n)

**示例**:
```
输入: nums = [1,2,3,1] → 输出: 2
步骤: mid=1, nums[1]<nums[2], left=2; mid=2, nums[2]>nums[3], right=2; 返回2
```

### 🎯 边界查找算法

#### 6. SearchRange (34. 在排序数组中查找元素的第一个和最后一个位置)
**题目**: 在排序数组中查找目标值的第一个和最后一个位置

**核心思想**: 二分查找 + 边界扩展
- **步骤**: 二分查找目标值 → 向左右扩展 → 返回边界
- **时间复杂度**: O(log n + k)
- **空间复杂度**: O(1)

**解题思路**:
1. 使用标准二分查找找到目标值
2. 从找到的位置向左右扩展
3. 找到第一个和最后一个目标值的位置
4. 返回边界数组

**关键技巧**:
- 扩展策略：从中心向两边扩展
- 边界检查：确保不越界
- 结果构建：返回 `[l+1, r-1]`

**示例**:
```
输入: nums = [5,7,7,8,8,10], target = 8 → 输出: [3,4]
```

#### 7. SearchRangeII (34. 在排序数组中查找元素的第一个和最后一个位置 - 优化版)
**题目**: 使用两次二分查找找边界

**核心思想**: 两次二分查找分别找第一个和最后一个位置
- **步骤**: 找第一个位置 → 找最后一个位置 → 返回结果
- **时间复杂度**: O(log n)
- **空间复杂度**: O(1)

**解题思路**:
1. 使用 `findFirst` 找第一个位置
2. 使用 `findLast` 找最后一个位置
3. 如果没找到第一个位置，直接返回[-1,-1]
4. 返回找到的边界

**关键技巧**:
- 两次查找：分别处理第一个和最后一个位置
- 查找策略：找到目标值后继续搜索边界
- 效率优化：从O(log n + k)优化到O(log n)

**示例**:
```
输入: nums = [5,7,7,8,8,10], target = 8 → 输出: [3,4]
```

### 🔄 旋转数组查找算法

#### 8. FindMin (153. 寻找旋转排序数组中的最小值)
**题目**: 在旋转排序数组中找最小值

**核心思想**: 二分查找 + 旋转数组特性
- **步骤**: 比较中间元素和右边界 → 判断位置 → 选择搜索方向
- **时间复杂度**: O(log n)
- **空间复杂度**: O(1)

**解题思路**:
1. 将旋转数组看作两个有序子数组
2. 比较 `nums[mid]` 和 `nums[right]`
3. 如果 `nums[mid] > nums[right]`，最小值在右侧
4. 否则，最小值在左侧或mid处

**关键技巧**:
- 旋转特性：利用旋转数组的特殊性质
- 比较策略：通过比较确定搜索方向
- 边界处理：使用 `left < right` 循环

**示例**:
```
输入: nums = [3,4,5,1,2] → 输出: 1
步骤: mid=2, nums[2]>nums[4], left=3; mid=3, nums[3]<=nums[4], right=3; 返回nums[3]=1
```

## 核心技巧总结

### 🔧 二分查找基础
- **标准模板**: `left <= right` 循环，`mid` 计算，边界更新
- **插入位置**: 未找到时 `left` 指针就是插入位置
- **边界处理**: 正确处理空数组和越界情况

### ⚡ 高级技巧
- **坐标转换**: 二维矩阵的一维化处理
- **趋势判断**: 通过比较相邻元素判断搜索方向
- **旋转数组**: 利用旋转数组的特殊性质
- **边界查找**: 两次二分查找分别找边界

### 🚀 优化策略
- **时间复杂度优化**: 从O(n)到O(log n)的优化
- **空间复杂度**: 所有算法都是O(1)空间
- **算法选择**: 根据问题特点选择最适合的算法

### 📈 时间复杂度分析
| 算法 | 时间复杂度 | 空间复杂度 | 核心思想 |
|------|-----------|-----------|----------|
| SearchInsert | O(log n) | O(1) | 标准二分查找 |
| SearchMatrix | O(m + log n) | O(1) | 先找行再查找 |
| SearchMatrixII | O(log(m×n)) | O(1) | 一维化二分查找 |
| FindPeakElement | O(n) | O(1) | 遍历找最大值 |
| FindPeakElementBs | O(log n) | O(1) | 二分查找峰值 |
| SearchRange | O(log n + k) | O(1) | 查找+扩展 |
| SearchRangeII | O(log n) | O(1) | 两次二分查找 |
| FindMin | O(log n) | O(1) | 旋转数组二分查找 |

## 学习路径建议

### 🎯 初学者路径
1. **SearchInsert** - 掌握标准二分查找模板
2. **SearchMatrix** - 理解二维矩阵的查找思路
3. **FindPeakElement** - 学习峰值查找的基本方法

### 🚀 进阶路径
1. **SearchMatrixII** - 学习坐标转换技巧
2. **FindPeakElementBs** - 掌握二分查找的变种应用
3. **SearchRangeII** - 理解边界查找的高级技巧

### 🔬 高级路径
1. **FindMin** - 掌握旋转数组的二分查找
2. 深入理解二分查找的各种变种
3. 学会根据问题特点选择最优算法

## 相关题目推荐
1. **35. Search Insert Position** - 基础二分查找
2. **74. Search a 2D Matrix** - 二维矩阵查找
3. **162. Find Peak Element** - 峰值查找
4. **34. Find First and Last Position** - 边界查找
5. **153. Find Minimum in Rotated Sorted Array** - 旋转数组查找
6. **33. Search in Rotated Sorted Array** - 旋转数组搜索
7. **69. Sqrt(x)** - 数学二分查找
8. **278. First Bad Version** - 边界查找应用

## 学习建议
1. **掌握标准模板**: 熟练使用二分查找的标准模板
2. **理解变种应用**: 学会根据问题特点调整算法
3. **注意边界处理**: 正确处理各种边界情况
4. **优化算法选择**: 根据时间复杂度要求选择最优算法
5. **练习坐标转换**: 掌握一维和二维索引的转换
6. **理解旋转数组**: 深入理解旋转数组的特殊性质
7. **掌握边界查找**: 学会使用两次二分查找找边界

## 相关资源
- [LeetCode Binary Search 题目](https://leetcode.com/tag/binary-search/)
- [二分查找详解](https://www.geeksforgeeks.org/binary-search/)
- [旋转数组算法](https://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/)
- [峰值查找算法](https://www.geeksforgeeks.org/find-a-peak-in-a-given-array/)
