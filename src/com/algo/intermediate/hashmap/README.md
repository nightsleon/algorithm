# Hashmap 算法

## 难度级别
Intermediate

## 包含算法
- TwoSum - 两数之和
- CanConstruct - 救赎信
- Isomorphic - 同构字符串
- WordPattern - 单词规律
- GroupAnagrams - 字母异位词分组
- ContainsNearbyDuplicate - 存在重复元素II
- LongestConsecutive - 最长连续序列
- **RomanToInt - 罗马数字转整数（新增）**
- **SubarraySum - 和为K的子数组（新增）**

## 核心思想
哈希表是解决查找问题的强大工具，通过空间换时间的思想，将查找操作的时间复杂度从 O(n) 降低到 O(1)。

## 算法详解

### 1. TwoSum - 两数之和
**题目**: 在数组中找出和为目标值的两个数的下标

**解题思路**:
1. 使用哈希表存储已遍历的元素及其下标
2. 遍历数组，对于每个元素 nums[i]，计算补数 target - nums[i]
3. 检查补数是否在哈希表中，如果在则找到答案
4. 如果不在，将当前元素及其下标加入哈希表

**时间复杂度**: O(n)  
**空间复杂度**: O(n)

**关键技巧**: 一次遍历，边遍历边查找，避免重复计算

### 2. CanConstruct - 救赎信
**题目**: 判断 ransomNote 能否由 magazine 中的字符构成

**解题思路**:
1. 统计 magazine 中每个字符的出现次数
2. 遍历 ransomNote，减少对应字符的计数
3. 如果某个字符计数变为负数，返回 false

**时间复杂度**: O(n + m)  
**空间复杂度**: O(1)，字符集大小固定

**关键技巧**: 字符计数数组比 HashMap 更高效

### 3. Isomorphic - 同构字符串
**题目**: 判断两个字符串是否为同构字符串

**解题思路**:
1. 建立双向字符映射：s -> t 和 t -> s
2. 遍历字符串，检查映射关系
3. 确保映射是一一对应的

**时间复杂度**: O(n)  
**空间复杂度**: O(1)，字符集大小固定

**关键技巧**: 双向映射防止多对一的情况

### 4. WordPattern - 单词规律
**题目**: 判断字符串是否遵循给定的模式

**解题思路**:
1. 建立双向映射：pattern -> word 和 word -> pattern
2. 遍历 pattern 和 words，检查映射关系
3. 确保映射是一一对应的

**时间复杂度**: O(n)  
**空间复杂度**: O(n)

**关键技巧**: 双向映射确保一一对应关系

### 5. GroupAnagrams - 字母异位词分组
**题目**: 将字母异位词分组

**解题思路**:
1. 使用字符计数数组作为 key，避免排序
2. 统计每个字符串中字符的出现次数
3. 将字符计数数组转换为字符串作为哈希表的 key
4. 相同 key 的字符串会被分到同一组

**时间复杂度**: O(n * k)，其中 k 是字符串平均长度  
**空间复杂度**: O(n * k)

**关键技巧**: 字符计数比排序更高效，固定大小数组比 HashMap 更快

### 6. ContainsNearbyDuplicate - 存在重复元素II
**题目**: 判断数组中是否存在距离不超过 k 的重复元素

**解题思路**:
1. 使用哈希表存储元素及其最新下标
2. 遍历数组，检查当前元素是否已存在
3. 如果存在且距离不超过 k，返回 true
4. 更新元素的最新下标

**时间复杂度**: O(n)  
**空间复杂度**: O(n)

**关键技巧**: 滑动窗口思想，只保留最新的下标信息

### 7. LongestConsecutive - 最长连续序列
**题目**: 找到数组中最长的连续数字序列长度

**解题思路**:
1. 将所有数字加入 HashSet
2. 只从连续序列的起点开始计算（num-1 不存在的数字）
3. 从起点向右扩展，统计连续序列长度
4. 更新最长连续序列长度

**时间复杂度**: O(n)  
**空间复杂度**: O(n)

**关键技巧**: 避免重复计算，每个数字最多被访问两次

### 8. RomanToInt - 罗马数字转整数（从ArrayStrSolution移入）
**题目**: 将罗马数字字符串转换为整数

**解题思路**:
1. 使用 HashMap 存储每个罗马字符对应的数值
2. 遍历字符串，比较当前字符与下一个字符的值
3. 如果当前值小于下一个值，则减去当前值（特殊情况：IV=4, IX=9）
4. 否则加上当前值（正常情况）

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: HashMap映射 + 特殊情况处理，处理罗马数字的减法规则

### 9. SubarraySum - 和为K的子数组（从ArrayStrSolution移入）
**题目**: 统计数组中和为 k 的连续子数组个数

**解题思路**:
1. 使用前缀和技巧：sum[j] - sum[i] = k，则 sum[i] = sum[j] - k
2. 用 HashMap 存储前缀和的出现次数
3. 遍历数组时，查找 (当前前缀和 - k) 是否存在
4. 如果存在，累加其出现次数

**时间复杂度**: O(n)  
**空间复杂度**: O(n)

**关键技巧**: 前缀和 + HashMap，将子数组和问题转化为前缀和查找问题


## 学习要点

### 1. 哈希表的核心优势
- **快速查找**: O(1) 时间复杂度的查找操作
- **空间换时间**: 用额外空间换取时间效率
- **去重功能**: 自动去除重复元素

### 2. 常见应用场景
- **查找问题**: 快速判断元素是否存在
- **计数问题**: 统计元素出现次数
- **映射问题**: 建立键值对关系
- **去重问题**: 去除重复元素

### 3. 优化技巧
- **初始容量**: 设置合适的初始容量避免扩容
- **字符计数**: 对于小字符集，使用数组比 HashMap 更高效
- **避免重复计算**: 一次遍历解决多个问题
- **边界处理**: 注意空值和边界条件

### 4. 时间复杂度分析
- **查找**: O(1) 平均时间复杂度
- **插入**: O(1) 平均时间复杂度
- **删除**: O(1) 平均时间复杂度
- **遍历**: O(n) 时间复杂度

## 相关题目推荐
1. **1. Two Sum** - 基础哈希表应用
2. **49. Group Anagrams** - 字符计数技巧
3. **128. Longest Consecutive Sequence** - 优化查找
4. **219. Contains Duplicate II** - 滑动窗口
5. **205. Isomorphic Strings** - 双向映射
6. **290. Word Pattern** - 模式匹配
7. **383. Ransom Note** - 字符计数

## 学习建议
1. 理解哈希表的基本原理和操作
2. 掌握空间换时间的思想
3. 学会分析时间复杂度和空间复杂度
4. 练习不同类型的哈希表应用
5. 注意边界条件和异常处理

## 相关资源
- [LeetCode Intermediate 题目](https://leetcode.com/problemset/all/?difficulty=INTERMEDIATE)
- [哈希表可视化](https://visualgo.net/en/hashtable)
- [Java HashMap 文档](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)
