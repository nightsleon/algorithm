# 双指针算法 (Two Pointers)

## 难度级别
Intermediate

## 包含算法
- IsPalindrome - 验证回文串
- IsSubsequence - 判断子序列
- TwoSumSorted - 两数之和（排序数组）
- ContainerWithMostWater - 盛最多水的容器
- Trap - 接雨水
- ThreeSum - 三数之和
- MinSubArrayLen - 长度最小的子数组
- LengthOfLongestSubstring - 无重复字符的最长子串
- IsPalindromeNumber - 回文数
- FindSubstring - 串联所有单词的子串
- FindAnagrams - 找到字符串中所有字母异位词
- MaxSlidingWindow - 滑动窗口最大值

## 核心思想
双指针技巧通过使用两个指针在数组或字符串中协同工作，通常能够将时间复杂度从 O(n²) 优化到 O(n)，是解决查找、比较、滑动窗口等问题的强大工具。

## 算法详解

### 1. IsPalindrome - 验证回文串
**题目**: 验证字符串是否为回文串，忽略大小写和非字母数字字符

**解题思路**:
1. 使用左右双指针从两端向中间移动
2. 跳过非字母数字字符
3. 忽略大小写进行比较
4. 如果所有对应字符都相等，则为回文串

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 字符过滤和大小写忽略，双指针向中间收敛

### 2. IsSubsequence - 判断子序列
**题目**: 判断字符串 s 是否为字符串 t 的子序列

**解题思路**:
1. 使用两个指针 slow 和 fast 分别遍历 s 和 t
2. 当 s[slow] == t[fast] 时，slow 指针前进
3. fast 指针始终前进
4. 如果 slow 到达 s 末尾，则 s 是 t 的子序列

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 快慢指针，一个指针控制匹配进度

### 3. TwoSumSorted - 两数之和（排序数组）
**题目**: 在已排序数组中找出和为目标值的两个数的下标

**解题思路**:
1. 使用左右双指针指向数组两端
2. 计算两指针指向元素的和
3. 如果和小于目标值，左指针右移
4. 如果和大于目标值，右指针左移
5. 如果和等于目标值，返回结果

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 利用排序特性，双指针向中间收敛

### 4. ContainerWithMostWater - 盛最多水的容器
**题目**: 找到两条线，使得它们与 x 轴围成的容器能容纳最多的水

**解题思路**:
1. 使用左右双指针指向数组两端
2. 计算当前容器的面积：min(height[left], height[right]) * (right - left)
3. 移动高度较小的指针（木桶效应）
4. 更新最大面积

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 木桶效应，移动较短的柱子

### 5. Trap - 接雨水
**题目**: 计算柱子之间能接到的雨水总量

**解题思路**:
1. 使用左右双指针和左右最大高度记录
2. 比较左右指针指向的柱子高度
3. 移动较矮的指针，更新对应侧的最大高度
4. 累加雨水：maxHeight - currentHeight

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 动态维护左右最大高度，移动较矮的指针

### 6. ThreeSum - 三数之和
**题目**: 找出数组中所有和为 0 的三元组

**解题思路**:
1. 先对数组排序
2. 固定第一个数，使用双指针查找剩余两个数
3. 跳过重复元素避免重复结果
4. 根据三数之和调整双指针位置

**时间复杂度**: O(n²)  
**空间复杂度**: O(1)

**关键技巧**: 排序 + 双指针 + 去重

### 7. MinSubArrayLen - 长度最小的子数组
**题目**: 找出满足其和大于等于目标值的最短子数组长度

**解题思路**:
1. 使用滑动窗口，右指针扩大窗口
2. 当窗口和大于等于目标值时，左指针缩小窗口
3. 记录最小窗口长度
4. 返回最小长度或 0

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 滑动窗口，动态调整窗口大小

### 8. LengthOfLongestSubstring - 无重复字符的最长子串
**题目**: 找出字符串中不包含重复字符的最长子串长度

**解题思路**:
1. 使用滑动窗口和 HashSet 记录字符
2. 右指针扩展窗口，添加新字符
3. 遇到重复字符时，左指针收缩窗口
4. 更新最大长度

**时间复杂度**: O(n)  
**空间复杂度**: O(min(m, n))，m 是字符集大小

**关键技巧**: 滑动窗口 + HashSet，动态维护无重复字符窗口

### 9. IsPalindromeNumber - 回文数
**题目**: 判断整数是否为回文数

**解题思路**:
1. 排除负数和末尾为 0 的数
2. 反转后半部分数字
3. 比较前半部分和反转后的后半部分
4. 处理奇偶长度的情况

**时间复杂度**: O(log n)  
**空间复杂度**: O(1)

**关键技巧**: 只反转后半部分，避免整数溢出

### 10. FindSubstring - 串联所有单词的子串
**题目**: 找出字符串中所有单词串联的子串起始位置

**解题思路**:
1. 使用滑动窗口和 HashMap 记录单词出现次数
2. 固定窗口大小为所有单词的总长度
3. 检查窗口内的单词是否匹配
4. 动态调整窗口位置

**时间复杂度**: O(n * m * k)，n 是字符串长度，m 是单词数量，k 是单词长度  
**空间复杂度**: O(m)

**关键技巧**: 滑动窗口 + HashMap，固定窗口大小

### 11. FindAnagrams - 找到字符串中所有字母异位词
**题目**: 给定两个字符串 s 和 p，找到 s 中所有 p 的异位词的子串，返回这些子串的起始索引

**解题思路**:
1. 使用滑动窗口和字符频次统计
2. 统计模式串 p 中每个字符的出现次数
3. 维护一个固定大小的滑动窗口（大小为 p 的长度）
4. 统计窗口内字符的频次，与模式串频次比较
5. 当窗口内字符频次与模式串完全匹配时，记录起始位置

**时间复杂度**: O(n × 26)，n 是字符串长度，26 是字符集大小  
**空间复杂度**: O(1)，使用固定大小的数组

**关键技巧**: 滑动窗口 + 字符频次统计，固定窗口大小

**优化建议**:
- 可以优化为 O(n) 时间复杂度，通过维护匹配状态而不是每次比较数组
- 使用 matchCount 变量记录匹配的字符种类数，避免 Arrays.equals() 调用

### 12. MaxSlidingWindow - 滑动窗口最大值
**题目**: 给定一个整数数组 nums 和一个整数 k，有一个大小为 k 的滑动窗口从数组最左侧移动到最右侧，返回每个滑动窗口中的最大值

**解题思路**:
1. 使用单调递减队列（双端队列）维护窗口内的最大值
2. 队列中存储数组下标，对应元素值单调递减
3. 每次添加新元素时，移除队列中所有小于新元素的元素
4. 维护窗口大小，移除过期的头部元素
5. 队列头部始终是当前窗口的最大值

**时间复杂度**: O(n)，每个元素最多入队一次，出队一次  
**空间复杂度**: O(k)，队列最多存储 k 个元素

**关键技巧**: 单调队列 + 滑动窗口，动态维护最大值

**核心思想**:
- **单调递减队列**：保证队列头部始终是最大值
- **下标存储**：存储下标便于判断元素是否过期
- **动态更新**：每次添加新元素时更新队列结构

## 学习要点

### 1. 双指针的核心优势
- **效率提升**: 将 O(n²) 优化到 O(n)
- **空间优化**: 通常只需要 O(1) 额外空间
- **逻辑清晰**: 两个指针协同工作，逻辑简单

### 2. 常见应用场景
- **查找问题**: 在有序数组中查找目标值
- **比较问题**: 字符串比较、回文判断
- **滑动窗口**: 子数组、子串问题
- **去重问题**: 去除重复元素

### 3. 双指针类型
- **对撞指针**: 从两端向中间移动
- **快慢指针**: 一个快一个慢
- **滑动窗口**: 维护一个可变区间

### 4. 优化技巧
- **排序预处理**: 利用排序特性简化问题
- **去重处理**: 跳过重复元素避免重复结果
- **边界处理**: 注意指针越界和边界条件
- **提前退出**: 找到答案后及时返回

### 5. 时间复杂度分析
- **对撞指针**: O(n) 时间复杂度
- **快慢指针**: O(n) 时间复杂度
- **滑动窗口**: O(n) 时间复杂度
- **嵌套双指针**: O(n²) 时间复杂度

## 相关题目推荐
1. **125. Valid Palindrome** - 基础回文判断
2. **392. Is Subsequence** - 子序列判断
3. **167. Two Sum II** - 排序数组两数之和
4. **11. Container With Most Water** - 经典双指针
5. **42. Trapping Rain Water** - 接雨水问题
6. **15. 3Sum** - 三数之和
7. **209. Minimum Size Subarray Sum** - 滑动窗口
8. **3. Longest Substring Without Repeating Characters** - 无重复字符子串
9. **9. Palindrome Number** - 回文数判断
10. **30. Substring with Concatenation of All Words** - 单词串联
11. **438. Find All Anagrams in a String** - 字母异位词
12. **239. Sliding Window Maximum** - 滑动窗口最大值

## 学习建议
1. 理解双指针的基本原理和适用场景
2. 掌握对撞指针、快慢指针、滑动窗口的区别
3. 学会分析时间复杂度和空间复杂度
4. 练习不同类型的双指针应用
5. 注意边界条件和异常处理
6. 理解排序对双指针算法的重要性

## 相关资源
- [LeetCode Intermediate 题目](https://leetcode.com/problemset/all/?difficulty=INTERMEDIATE)
- [双指针技巧总结](https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/shuang-zhi-zhen-ji-qiao)
- [滑动窗口算法](https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/)
