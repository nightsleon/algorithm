# 双指针算法 (Two Pointers)

## 难度级别
Intermediate

## 包含算法
- IsPalindrome - 验证回文串
- IsSubsequence - 判断子序列
- TwoSumSorted - 两数之和（排序数组）
- ContainerWithMostWater - 盛最多水的容器
- Trap - 接雨水
- ThreeSum - 三数之和
- IsPalindromeNumber - 回文数
- MoveZeroes - 移动零
- **Merge - 合并两个有序数组（从ArrayStrSolution移入）**
- **RemoveElement - 移除元素（从ArrayStrSolution移入）**
- **RemoveDuplicates - 删除有序数组中的重复项（从ArrayStrSolution移入）**
- **ReverseWords - 反转字符串中的单词（从ArrayStrSolution移入）**

## 核心思想
双指针技巧通过使用两个指针在数组或字符串中协同工作，通常能够将时间复杂度从 O(n²) 优化到 O(n)，是解决查找、比较等问题的强大工具。

**主要类型**：
- **对撞指针**：从两端向中间移动
- **快慢指针**：一个快一个慢
- **数字双指针**：用于数字操作（如回文数判断）

## 算法详解

### 1. IsPalindrome - 验证回文串
**题目**: 验证字符串是否为回文串，忽略大小写和非字母数字字符

**解题思路**:
1. 使用左右双指针从两端向中间移动
2. 跳过非字母数字字符
3. 忽略大小写进行比较
4. 如果所有对应字符都相等，则为回文串

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 字符过滤和大小写忽略，双指针向中间收敛

### 2. IsSubsequence - 判断子序列
**题目**: 判断字符串 s 是否为字符串 t 的子序列

**解题思路**:
1. 使用两个指针 slow 和 fast 分别遍历 s 和 t
2. 当 s[slow] == t[fast] 时，slow 指针前进
3. fast 指针始终前进
4. 如果 slow 到达 s 末尾，则 s 是 t 的子序列

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 快慢指针，一个指针控制匹配进度

### 3. TwoSumSorted - 两数之和（排序数组）
**题目**: 在已排序数组中找出和为目标值的两个数的下标

**解题思路**:
1. 使用左右双指针指向数组两端
2. 计算两指针指向元素的和
3. 如果和小于目标值，左指针右移
4. 如果和大于目标值，右指针左移
5. 如果和等于目标值，返回结果

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 利用排序特性，双指针向中间收敛

### 4. ContainerWithMostWater - 盛最多水的容器
**题目**: 找到两条线，使得它们与 x 轴围成的容器能容纳最多的水

**解题思路**:
1. 使用左右双指针指向数组两端
2. 计算当前容器的面积：min(height[left], height[right]) * (right - left)
3. 移动高度较小的指针（木桶效应）
4. 更新最大面积

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 木桶效应，移动较短的柱子

### 5. Trap - 接雨水
**题目**: 计算柱子之间能接到的雨水总量

**解题思路**:
1. 使用左右双指针和左右最大高度记录
2. 比较左右指针指向的柱子高度
3. 移动较矮的指针，更新对应侧的最大高度
4. 累加雨水：maxHeight - currentHeight

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 动态维护左右最大高度，移动较矮的指针

### 6. ThreeSum - 三数之和
**题目**: 找出数组中所有和为 0 的三元组

**解题思路**:
1. 先对数组排序
2. 固定第一个数，使用双指针查找剩余两个数
3. 跳过重复元素避免重复结果
4. 根据三数之和调整双指针位置

**时间复杂度**: O(n²)  
**空间复杂度**: O(1)

**关键技巧**: 排序 + 双指针 + 去重

### 7. IsPalindromeNumber - 回文数
**题目**: 判断整数是否为回文数

**解题思路**:
1. 排除负数和末尾为 0 的数
2. 反转后半部分数字
3. 比较前半部分和反转后的后半部分
4. 处理奇偶长度的情况

**时间复杂度**: O(log n)  
**空间复杂度**: O(1)

**关键技巧**: 只反转后半部分，避免整数溢出

### 8. MoveZeroes - 移动零
**题目**: 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序

**解题思路**:
1. 使用快慢指针，快指针遍历数组
2. 当快指针指向非零元素时，将其赋值给慢指针位置
3. 慢指针只有在赋值后才前进
4. 最后将慢指针之后的位置都填充为 0

**时间复杂度**: O(n)  
**空间复杂度**: O(1)

**关键技巧**: 快慢指针，原地操作

## 学习要点

### 1. 双指针的核心优势
- **效率提升**: 将 O(n²) 优化到 O(n)
- **空间优化**: 通常只需要 O(1) 额外空间
- **逻辑清晰**: 两个指针协同工作，逻辑简单

### 2. 常见应用场景
- **查找问题**: 在有序数组中查找目标值
- **比较问题**: 字符串比较、回文判断
- **去重问题**: 去除重复元素

### 3. 双指针类型
- **对撞指针**: 从两端向中间移动
- **快慢指针**: 一个快一个慢
- **数字双指针**: 用于数字操作

### 4. 优化技巧
- **排序预处理**: 利用排序特性简化问题
- **去重处理**: 跳过重复元素避免重复结果
- **边界处理**: 注意指针越界和边界条件
- **提前退出**: 找到答案后及时返回

### 5. 时间复杂度分析
- **对撞指针**: O(n) 时间复杂度
- **快慢指针**: O(n) 时间复杂度
- **数字双指针**: O(log n) 时间复杂度
- **嵌套双指针**: O(n²) 时间复杂度

## 相关题目推荐
1. **125. Valid Palindrome** - 基础回文判断
2. **392. Is Subsequence** - 子序列判断
3. **167. Two Sum II** - 排序数组两数之和
4. **11. Container With Most Water** - 经典双指针
5. **42. Trapping Rain Water** - 接雨水问题
6. **15. 3Sum** - 三数之和
7. **9. Palindrome Number** - 回文数判断
8. **283. Move Zeroes** - 移动零

## 学习建议
1. 理解双指针的基本原理和适用场景
2. 掌握对撞指针、快慢指针的区别
3. 学会分析时间复杂度和空间复杂度
4. 练习不同类型的双指针应用
5. 注意边界条件和异常处理
6. 理解排序对双指针算法的重要性

## 相关资源
- [LeetCode Intermediate 题目](https://leetcode.com/problemset/all/?difficulty=INTERMEDIATE)
- [双指针技巧总结](https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/shuang-zhi-zhen-ji-qiao)
- [双指针算法详解](https://leetcode.com/problems/container-with-most-water/solution/)
